> [!note]+
> 요구사항 명세 설계단계
> 
> - 아키텍쳐 디자인 결정
> - 관점들
> - 패턴들
> - 아키텍쳐 적용

# Software architecture
- 아키텍쳐 설계
	- 시스템을 구성하는 서브시스템 및 서브시스템간의 제어 및 통신을 식별하는 과정
	- 명세 및 설계간 링크 역할 
	- (object, class 아님, 시스템 단위라 추상화단위가 큼)

- 소프트웨어 아키텍쳐 : 아키텍쳐 설계의 산출물
- 장점
	- stakeholder간의 의사소통 증진
	- 시스템 분석 수행시 시스템의 비기능적 요구사항 달성 여부 분석
	- 큰 규모의 재사용 : 아키텍쳐 단위로 여러 시스템에 재사용될 수 있음


## 아키텍쳐 추상화
- 작은 단위에서 아키텍쳐
	- 프로그램 단위의 아키텍쳐
	- 단위 프로그램이 어떠한 컴포넌트로 구성되었는지 연구
- 큰 단위의 아키텍쳐
	- 복잡한 엔터프라이즈 시스템의 아키텍쳐를 다룸
		- 엔터프라이즈 시스템은 대개의 경우 다수의 컴퓨터에 분산되며 여러 회사에 의해 소유되고 운영됨
	- 엔터프라이즈 시스템을 이루는 타 시스템, 프로그램 및 프로그램 컴포넌트에 대해 연구

# 아키텍쳐 설계 결정
## Architectural design decisions
- 아키텍쳐 설계는 개발하고자 하는 시스템에 따라 다르게 진행되나, 다음과 같은 의사결정은 공통적으로 이루어짐
	- 사용가능한 일반적인 어플리케이션 아키텍쳐가 있는가?
	- 시스템이 어떻게 분산될 수 있는가?
	- 어떤 스타일이 좋은가?
	- 시스템을 구조화하기 위해 어떤 접근법을 사용할 수 있는가?
	- 시스템이 어떻게 모듈로나누어 질 수 있는가?
	- 어떤 통제 전략을 사용할 수 있는가?
	- 어떻게 평가?
	- 문서화는 또 어떻게?

## Architecture and system characteristics
- performance
	- 중요 오퍼레이션을 국소화시키고, 커뮤니케이션을 최소화
	- 작은 단위 컴포넌트보다는 큰단위 컴포넌트를 사용
- Security 
	- 계층적 아키텍쳐를 사용하고, 중요한 자산은 안쪽 게층에 위치시킴
- Safety
	- 안전에 영향을 주는 중요한 features는 작은 수의 sub-system에 위치시켜 국소화사킬거 -> 집중화(펼치기 x)
- Availability(가용성)
	- 중복된 컴포넌트를 포함시키고, 결함 허용을 위한 케머니즘을 도입
- Mainainability
	- 작은 크기의 컴포넌트를 사용, 대체할 수 있는 컴포넌트 사용

## Architectural views
- 각 아키텍쳐 모델은 시스템의 특정 관점만을 보기 때문에 여러 view를 통해 시스템의 아키텍쳐 묘사하는 것이 좋음

## 4 + 1 View model of software architecture
- logical view : object, object classes와 같은 주요 추상화내용을 보임
- process view : 시스템이 수행중에 어떤 프로세스들로 구성되는지를 보임
- Development(implementation) view : 소프트웨어가 개발과정에서 어떻게 나누어지는가를 보임
- Physical view : 시스템을 구성하는 하드웨어와 소프트웨어가 어떻게 분산되어 있는지를 보임
- 유즈케이스나 시나리오를 사용해서 (+1)

![](https://i.imgur.com/i0jRrya.png)
![](https://i.imgur.com/hT57zg9.png)


## Document
각 관점에 대해 작성해야함
# Architectural Patterns
## Archtectural Patterns
- Patterns : 지식을 표현하고, 공유하고, 재사용하기 위한 수단
- An architectural patterns : 여러 환경에서 시도, 테스트되어 유용함이 입증된 사례
- 표현 방법 : 표나 그림, 설명도 포함

### [1] MVC 패턴
표현, 연결, 시스템 데이터를 구분 - 3개의 논리적 컴포넌트로 구조화됨
	- model component : 시스템 데이터 및 데이터와 연관된 operations을 관리하는 컴포넌트
	- View component : 데이터가 사용자에게 표현되는 것을 정의하고 관리하는 컴포넌트
	- Controller component : 사용자와의 상호작용을 관리하고 상호작용 내용을 view, model에 전달

언제사용?
	- 데이터를 여러 방식으로 보여주고 상호작용하는 경우
	- 데이터에 대한 향후 상호작용과 표현양식이 확정적이지 않은 경우

장점
	- 데이터에 대한 변경이 표현양식과는 별개로 수행될 수 있음
	- 동일 데이터를 여러 형태로 표현하고자 할 때, 임의의 표현형식에서변경된 내용을 다른 형태에서도 보여주고 싶을 때

단점
	- 모델 및 상호작용이 간단하면 코드가 복잡해짐


### [2] Layerd Architecture
- 서브시스템의 언터페이싱을 만들기위해 사용
- 시스템을 Layer의 집합으로 조직(또는 추상 머신). 이때 각 Layer는 관련된 서비스의 집합으로 구성됨
- Layer단위로 incremental 개발이 가능하도록 지원
- 임의의 Layer가 변경될 경우 인접한 Layer만 영향을 받음
- 하지만 종종 인위적임
#### Pattern
설명 : 
	- 시스템을 레이어로 나누고, 각 레이어는 관계된 기능을 연관시킴
	- 임의의 레이어는 차상위 레이어에게 서비스를 제공, 가장 낮은 계층은 전체 시스템에 모두 사용될 커버 서비스를 제공

사용시기 
	- 기존 시스템위에 새로운 기능을 추가하고자 할때
	- 시스템 개발이 여러 팀을 통해 이루어지고, 각 팀이 임의 레이어의 기능을 책임지는 경우
	- 멀티 레벨 보안이 필요한 경우

장점
	-  인터페이스를 유지하는 한 레이어 전체 변경이 쉬움
	- 각 레이어에서 임의의 기능을 중복하여 제공할 수 있고, 이를 통해 전체 시스템의 의존성을 높일 수 있음

단점
	- 레이어간 명확한 구분이 어려움, 상위레이어가 차하위 레이어와 상호작용하지 않고 직접적으로 하위 레이어와 관계할 수도 있음
	- 성능면에서 문제(임의의 서비스는 여러단계에 걸쳐 해석이 이루어짐)
![](https://i.imgur.com/2ETAJYE.png)

### [3] Repository architecture
서브 시스템간 데이터 교환 방법
- **공유 데이터를 중앙 데이터베이스 혹은 레퍼지토리에 넣고, 모든 서비시스템이 이를 접근할 수 있도록함**
- 각 서브시스템은 자신만의 데이터베이스를 유지, 필요할 때마다 그 데이터를 다른 서브시스템에 전달

대규모의 데이터가 공유되어야 하는 경우에 적합
![](https://i.imgur.com/wdZYdRn.png)
![](https://i.imgur.com/3t13681.png)


### [4] Client- server architecture
분산된 시스템 모델
- 데이터와 데이터의 처리가 컴포넌트 사이에서 어떻게 분산되어 있는가를 보임
- 단일 컴퓨터상에서도 구현될 수도 있음

구성요소
- Set of stand-alone servers : 서비스를 제공(printing, data management)
- Set of clinets : 서비스 호출
- Nerwork : 클라이언트가 서버를 접근할 수 있도록 함
![](https://i.imgur.com/EWdh2G2.png)

![](https://i.imgur.com/Zm7NjmI.png)


### [5] Pipe and filter architecture
입력을 함수 트랜스포메이션에 적용시켜 출력을 생성

파이프 필터모델로 알려짐

상호작용적 시스템에는 적합하지 않음

![](https://i.imgur.com/DOK7VLt.png)

![](https://i.imgur.com/fMhl21a.png)

### [6] Broker Pattern
분리된 컴포넌트들로 이루어진 분산시스템에서 사용
브로커 : 요청 전달과 결과 및 예외 전송과 같은 통신을 조정하는 역할을 담당
서버 : 브로커에 자신의 인터페이스를 등록하여 클라이언트에 서비스를 제공
클라이언트 : 브로커에 서버의 서비스를 정적, 동적으로 조회하여 요청

![](https://i.imgur.com/E9hFyaE.png)

단점
- 중악집권적 브로커 
- 메세지 루틴으로인한 잠재가능
- 브로커의 수용능력이 전체 시스템의 scalability에 영향

### [7] Peer to Peer
노드는 클라이언트면서 동시에 서버임

모든 리소스가 중앙 서버 없이 모두에게 공유됨

단점 노드간 직접 연결로 인한 보안 부재, 중앙제어의 부재로 인한 협력도 복잡가능


# Application 아키텍쳐
## 어플리케이션 아키텍쳐
어플리케이션 시스템은 특정 조직의 필요를 만족하기 위해 설계되나, 일반적으로 비즈니스는 공통점이 많기 때문에 공통적인 아키텍쳐를 가짐

일반적인 어플리케이션 아키텍쳐
- 특정 소프트웨어 시스템 타입에 적합한 아키텍쳐
- 특정 요구사항을 만족하도록 형상화되고 변경됨

## 어플리케이션 타입 예시
- 데이터 처리 : 데이터에 따라 진행되는 어플리케이션으로는 데이터는 배치방식으로 처리됨
- 트랜잭션 처리 : 데이터 중심 어플리케이션으로 사용자의 요청사항을 처리하고 이에따라 시스템 데이터베이스의 정보를 수정함
- 이벤트 처리 시스템 : 외부환경에서부터발생되는 이벤트를 해석하고 이에 따른 액션을 취하는 어플리케이션
- 언어 처리 시스템 : 사용자의 의도하는 바를 formal언어로 명세하고, 이 formal언어를 해석하여 시스템에서 처리하는 어플리케이션
