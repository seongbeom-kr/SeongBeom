
## Verificatino vs Validation
verification : 소프트웨어가 관련 명세에 부함하는지 컴토
validation : 소프트웨어는 사용자가 원하는 바를 수행해야함

## confidence
시스템이 목적에 부합함을 증명하는 것
부합 정도에 영향을 주는 요인
- 목적 : 소프트웨어가 해당 조직(사용자)에 얼만큼 중대한지에 따라 부합정도가 다름
- 사용자 기대치 : 사용자는 특정 소프트웨어에 대해 낮은기대치를 가질 수 있음
- 시장 환경 : 시장에 빠르게 출시하는 것이 프로그램의 오류를 찾는 것보다 중요한 경우도 있음

## Program 테스트
실제 사용하기 전에 프로그램의 오류를 발견하는 과정(프로그램이 의도된 대로 동작함을 보이는 과정)

테스트 특징
- 가공의 데이터를 이용하여 프로그램을 수행
- 테스트 결과 오류나 비정상적 상황이 있는지 파악
- 프로그램의 비기능적 속성들에 대한 정보를 얻음
- 에러가 있음을 보일 수 있으나 에러가 없음을 보일 수는 없음
- 테스팅은 V&V의 부분 -> 테스팅 뿐만 아니라 정적 검증 기법등도 사용한다.

### 목표
개발자 및 고객에게 소프트웨어가 요구사항을 만족함을 증명 -> Validation Testing
- for custom software : 요구사항 명세서에 있는 모든 요구사항에 대해 적어도 하나의 테스트 수행
- for generic software product : 모든 시스템 기능에 대한 테스트 + 기능들의 각종 조합에 대한 테스트

소프트웨어가 올바르지 않거나 명세에 부합하지 않은 상황을 발견(_detect testing_)
- 원인을 파악


![](https://i.imgur.com/HeUjo61.png)

# Inspection and Testing
## Inspection and Testing
inspection
- static verification
- 정적 모습을 분석
- 도구 및 코드 분석기를 통해 수행됨

software 테스팅
- 동적 분석
- 제품을 여러 형태로 수행하여 이때 행동 양식을 관찰
- 테스트데이터를 가지고 시스템을 수행한 후 operational behavior를 관찰함

## Inspections
사람이 소스코드를 보고 오류를 찾음 -> 시스템을 수행할 필요가 없기 때문에 구현 전에 수행될 수 있음
시스템의 다양한 형태에 적용할 수 있음(요구사항, 디자인 등등)

### 절차
시스템 overview : 시스템에 대한 개략적 설명을 검사팀에게 설명함
코드및 관련 서류를 인스펙션 팀에 먼저 배포함
검사 체크리스트에 따라 검사를 수행하고 발견된 에러들을 기록함
발견된 에러를 수정하기 위한 조치를 수행
필요에 따라 재검사 수행

### inspection roles
저자나 주인 : 프로그램 개발담당자, 인스펙션에 의해 발견된 결함사항들을 수정할 책임이 있음
검사자 : 에러, 생략된 사항, 불일치 사항 등을 발견할 담당자
읽는 사람 : 코드 표현
기록자 : 결과기록
체어맨, 모더레이터 : 과정 진행
주 모더레이터 : 인스펙션 향상, 체크리스트 업데이트, 스탠다드 개발 등의 역할 수행

### inspectino checklists
- 프로그래밍 언어 의존성
- 해당 언어에서 자주 발생하는 에러들을 리스트로 만들어 검사에 사용
- 프로그래밍 언어가 약한 타입일수록 리스트가 큼

#### 체크요소
- data faults : 초기화, 상수 명명, 배열사이즈, 오버플로우 등
- control faults : 조건 정확, 무한루프방지, 등
- input / output faults 입력, 출력 변수 상태 확인, 예상외 입력 유도
- interface faults : 파라미터 정확? 전달? 타입호환? 
- storage managements : 저장 방법에 대한 이야기
- exception managements : 예외 조건 다 만족?

### inspection rate
비용이 많이 듬

### 검사의 장점
테스트 동안은 다른에러를 숨길 수 있지만, 검사는 정적 분석방법이기에 에러간 상호작용에 대해 우려할 필요없음

프로그램 완성 전에 테스트하기 위해서는 test harness를 별도로 개발해야하는 것과 달리, 시스템이 불완전버전인 상태에서도 적용될 수 있음

프로그램 오류를 찾아내는 것외에 프로그램의 품질적 요소들을 검토할 수 있음


### 검사와 테스트
검사와 테스트는 상호보완적이며 반대적인 검증기술이 아님

v&v과정에서 둘다 사용함
검사를 통해 스펙과의 부합 정도를 검토할 수는 있지만, 고객이 원하는 요구사항에 부합했는가를 검토할 수 없음

검사는 성능, 사용의 편의성과 같은 비기능적 요구사항을 검토할 수 없음

### Automated static analyzer
- 프로그램 텍스트를 나누어 에러가 발생할 수 발견해 냄
- 검사 시 매우 효과적으로 활용될 수 있음

### 동적 분석 단계
- 컨트롤 흐름 분석 : 도달 할 수 없는 코드 부분이 있는지 확인 
- 데이터 사용 분석 : 초기화 되지 않은 변수가 있는 지 데이터 사용에 대한 오류 검토
- 인터페이스 분석 : 프로시져 선언과 사용이 일치하는지 검토
- 정보 흐름 분석 : 출력 변수간의 연관성 식별 -> 분석을 위한 정보제공
- path 분석 : 프로그램의 path and path를 이루는 구문들을 식별 -> 오류 발견이 아니라 분석을 위한 정보제공
- 코드 리뷰 등

# Testing

## 테스트 과정
테스트 케이스 구성 -> 데이터 준비 -> 실행 -> 각 테스트 케이스결과를 비교 -> (공식 보고)

## 테스트 단계(3단계로 진행)
development testing : 개발 중에 시스템을 테스트하여 버그, 감지 발견
release testing : 분리된 테스트 팀이 
user testing

## system testing

## testing policies

도서관 사례

이용고객이 어떻게 사용할지에 대해 시퀀스 다이어그램

# Release Testing
- 시스템의 특정 릴리즈를 테스트
- 시스템 공급자에게 해당 시스템이 사용하기에 충분히 좋음을 확신시키게 됨
	- 명시된 기능을 전달하며 요구되는 성능 및 의존성을 달성하며 일상적인 사용에서 fail되지 않음을 보여주어야 함
- 보통의 경우 black-box 테스트, 테스트는 시스템 명세서를 통해 추출하게 됨

## 릴리즈 테스트 시스템 테스트
릴리즈 테스트는 시스템 테스트의 형태임
차이점
- 시스템 개발에 관여하지 않은 별도 팀에서 수행
- 개발팀 -> 버그 발견하는데 중점
- 릴리즈 테스트는 요구사항을 만족하며 외부조직에서 사용되기 충분함을 보이는데 중점

요구사항 기반 테스트와 시나리오 기반 테스트 두개로 구분됨


## Performance test
릴리즈 테스트의 부분으로 성능 및 신뢰성과 같은 시스템의 emergent properties를 테스트

테스트는 시스템 _프로파일_ 을 반영해야함

퍼포먼스 테스트들은  대개의 경우 load를 _서서히 증가_ 시켜가며 다수의 테스트를 하며서 언제 시스템의성능이 허용치를 넘게 되는지 확인

스트레스 테스팅
- performance test로 시스템에 고의적으로 과부화를 걸어 행동 관찰

# Uesr Testing
유저(또는 고객; 고객은 특정 고객군, 고객사를 뜻함) 테스트는 유저와 코객이 입력을 생성하게 됨

유저 테스트는 필수적임 (릴리즈 테스트가 수행되었더라도)

- 준비된 테스팅 환경과 _다른 사용자의 작업환경_ 이 시스템의 특징에 많은 영향을 주기 때문

## Types of user Testing
- Alpha test
	- 사용자가 개발자 관점에서 개발팀과 같이 테스트
- Beta 
	- 소프트웨어를 릴리즈하여 사용자에게 준 후 사용자들이 이를 써보도록 함, 이후 발견 문제를 개발자에게 보고
- Acceptance testing
	- 고객이 테스트 수행, 테스트를 통해 accept해서 고객의 환경에 배치할 것인지 여부를 결정, 대개의 경우 커스텀 시스템의 경우 해당됨




