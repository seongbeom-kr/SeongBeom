#DB 
# Indexing
> Indexing Basic Concept
> Ordered Indices
> $B^{+}$ - Tree Index Files
> $B^{-}$ - Tree Index Files 


## Basic Concept
인덱스는 데이터에 효율적인 접근을 돕는 데이터 구조다.
![[스크린샷 2024-05-28 11.23.40.png]]


- 인덱싱 메커니즘은 원하는 데이터에 접근 속도를 높이기 위해 사용된다.

- __Search Key__ : 파일에서 튜플(레코드)를 찾기 위해 사용되는 속성들의 집합(또는 속성 하나)

- __Index file__ 은 레코드 형태로 구성된다. // index entries or record

- 인덱스 파일들은 원본 파일보다 매우 작음

- Indices의 두가지 기본 종류
	- 정렬된 Indices : Search Keys가 정렬된 상태로 저장된다.
	- Hash Indices : 해쉬함수를 사용

## Ordered Indices $\star^5$ 
- 정렬된 인덱스에서, 인덱스 엔트리들은 search key 값에 정렬된 상태로 저장된다.

- Primary index : 순차적으로 저장된 파일에서는, search key의 인덱스는 파일의 순차적인 정렬을 명시한다.
	- 클러스터링 인덱스라고도 함
	- 기본 인덱스의 search key는 보통 기본키이지만 필수는 아니다.

- Secondary index : 검색키의 인덱스는 순차정렬된 파일과 다른 형태의 정렬을 명시한다.
	- Non - clustering

- Index - sequential file : 기본인덱스를 가진 순차정렬 파일 

## Dense Index Files 
- Dense index : 인덱스 레코드는 파일에 있는 모든 검색키 값에 대해 나타낸다
- `Dense`라 불리는 이유는 데이터 파일의 모든 키가 인덱스에서 표현되기때문이다.
- 덴스 인덱스는 Key들을 그 파일 자체 순서와 동일하게 유지된다.
- 키와 포인터만 보유한 인덱스는, 완전한 레코드보다 훨씬 적은 공간을 차지하기 때문에 파일 자체보다 훨씬 적은 공간을 소모할 것이다.
- 즉, 파일보단 메모리를 위해 설계된 것이다.
- 또한 인덱스를 사용하면 searchKey를 통해 어떤 레코드던 찾을 수 있다.
![](https://lucid.app/publicSegments/view/7203baa6-7dce-4f04-98f1-f66ad6cb09d3/image.png)

- Dens index는 인덱스 블록을 주어진 Search Key 값으로 검색하며, 찾을 경우 그 포인터로 연관된 레코드를 따라간다.
- 이때 찾을때까지 인덱스의 모든 블록을 탐색(평균적으로는 절반만큼)
- 성능이 괜찮음

왜?
1. 인덱스 블록의 수는 대개 데이터 블록의 수보다 비교적 적다
2. 키값들이 정렬되어있기 때문에 이진탐색을 할 수 있다. $log_2n$
3. 인덱스는 메인 메모리 버퍼에 영구 유지될 수 있을 만큼 작다

## Sparse Index Files 
> - 하지만 Dense index는 모든키를 가지고 있기에는 비교적 크다
> - 이런 단점을 보완하여 설계한 것이 바로 Sparse Index라고 한다.


- 데이터 블록마다 오직 한 개의 Key - Pointer 쌍을 보유한다.
- 훨씬 적은 공간을 사용하지만 주어진 레코드의 Key를 찾는데 더 많은 시간이 걸린다.
- ![](https://lucid.app/publicSegments/view/b86349a6-1468-49be-bc4f-893c5ec5fe19/image.png)
- Sparse index는 주어진 검색키 값보다 작거나 같은 값중 가장 큰 값을 찾는다.
- 이진탐색가능, 찾은 다음에는 블럭 탐색

## Multiple Level Index
-  인덱스 자체로는 많은 블록을 커버할 수 있는 장점이 있지만, 이진 탐색으로 인덱스를 찾더라도, 원하는 레코드를 찾고자하면 오래걸릴 수 있음
- 이럴때 인덱스를 위한 인덱스를 사용
![](https://lucid.app/publicSegments/view/395be250-b56a-4507-896c-9b217e909e79/image.png)

## Secondary Indices
- 종종, 사람들은 어떤 조건을 만족하는 특정 필드에 있는 값들을 가진 모든 레코드들을 찾길 원한다.
- secondary index를 사용해서 찾는다.
- search-key 값에 대한 인덱스 레코드가 있는 secondary index를 가질 수 있음
- index 레코드는 특정 검색키값을 가진 모든 실제 레코드에 대한 포인터를 포함하는 buket을 포인트한다
- secondary index는 정렬되어 있지 않은 값을 표시하기 때문에 Dense하지 않으면 찾아갈 수 없음(index가 모든 포인터를 포함한다.)

![](https://i.imgur.com/j31YaU4.png)

## Primary and Secondary Indices
- 인덱스는 레코드를 검색할 때마다 상당한 이익을 준다(효율적이기 때문에!)
- 그러나 데이터가 바뀔 때마다 인덱스를 모두 업데이트 해주어야 하기때문에 비용이 발생함
- 순차적인 스캔을 사용할 시 Primary index를 사용하는 것이 효율적, Secondary index는 비효율적
	- 레코드에 접근하는 방식은 새로운 블록을 디스크에서 갖고오는데 블록에 접근하는데 걸리는 시간은 메모리에 접근하는 시간보다 비효율적이다
	- 스캔은 레코드를 한번 훑는데 그때 primary index는 디스크에 시퀀셜하게 저장되어있기 때문에 쉽게 가져올 수 있음, 하지만 secondary index는 정렬되어있지 않기 때문에(시퀀셜하지 않음) 디스크를 올렸다 내렸다 반복하게 되어서 (한번에 가지고 오는것이 아니기 때문) 과부화가 발생한다.

## B+ tree index files
> [!note] 정렬된 인덱스 파일의 문제점 
> 파일 사이즈가 커질 수록 성능이 하락함
> 주기적인 전체 파일의 재구조화가 요구됨

![](https://i.imgur.com/mVmulOH.png)
- Leaf : 실제 포인터
- 비교값이 크거나 같으면 value(search key)다음 포인터를 찾아감
- Null pointer -> 가르키는 포인터가 없음(마지막에 삽입)

- B+ tree는 indexed-sequential files의 대안이다
- 장점
	- 삽입 및 삭제시 스스로 small local 하게 재구성하고 변화함
	- 성능유지에 전체 파일 재구성이 필요하지 않음
- 단점
	- 추가 삽입, 삭제 시 space overhead됨 (칸을 밀어야하기 때문에)
- 하지만 장점이 더 크다
- B+트리는 다음의 성질을 만족하는 rooted tree임
	n = node내의 포인터 수
	루트부터 리프까지 모든 경로가 같은 길이를 가짐(검색 시간이 일정)
	루트 또는 리프가 아닌 각각의 노드는 n/2~n개의 자식을 가진다(포인터수)
	리프노드는 (n-1)/2 ~n-1의 값을 가진다. (search key수)
	예외
		루트는 리프가 아닌 경우 최소 두개의 자식을 가짐
		루트가 리프인 경우 0~n-1의 값을 가진다(값 이외에 다른 노드가 없는 경우)

- B+트리는 리프를 고정시키고 바텀업 방식으로 제작
	- Fan-out : 노드당 search key 값 수
	- 
- leaf node in B+ 트리 : 리프노드의 성질
	- 포인터 P_i 는 검색키 값 K_i 를 가르킨다.
	- i< J 일경우, L_i 검색키 값은 L_j의 값보다 작거나 같다(정렬되어있음을 시사)
	- P_n 포인터는 search key order가 남아있는 다음 리프노드를 가르킨다. 마지막 포인터는 다음 노드로 넘어감
	- 
- Non - leaf node in B+ 트리
	- 리프노드가 아닌 노드는 리프 노드에 대해 멀티레벨 sparse index가 형성됨
		- P_1 포인트가 K-1보다 작은 하위트리의 검색키
		- 2<=i <= n-1, P_i 포인터들은 K_i-1 보다 크거나 같고 K_i보다는 작은 모든 검색키들을 하위 트리로 가진다.
		- 하위 트리의 검색키는 포인터 P_n이 가진 값은 K_n-1의 값보다 크거나 같다
![](https://i.imgur.com/iCSaPu6.png)
	
## Observation about B+Tree
- 노드간 연결은 포인터에 의해 이루어지기 때문에 논리적으로 가까운 블록이 물리적으로 가까울 필요는 없음
- B+트리의 non-leaf level은 수직적으로 sparse index를 가진다.
-  B+트리는 비교적 적은 수의 리프를 가진다.
	- 루트의 하위 수준은 2* [n/2]
	- 다음 수준은 최소 2* [n/2] ^2의 값을 가진다.
	- 만약 검색키가 파일안에 있다면 트리의 높이는 [log_n/2 k]를 넘지 않는다.
	- 소규모이기 땜누에 어느 정도 효율적으로 검색이 가능
- 인덱스를 logarithmic time내에 재구성할 수 있기 땜누에 메인 파일에 대한 삽입 및 삭제를 효율적으로 처리할 수 있다.

## B-트리 인덱스 파일
- B+트리와 유사하지만., B-트리는 검색키값이 한번만 표시되므로 검색키의 중복저장이 제거됨
- 리프 노드가 아닌 노드의 검색키가 B-트리의 다른 곳에 표시되지 않음
- 리프 노드가 아닌 노드에서 검색키에 대한 추가 포인터 필드를 표시해야함
	- 
![](https://i.imgur.com/i4XN3SN.png)

- B-트리의 장점
	- 똑같은 비플러스 트리보다 노드가 적을 수 있다.
	- search key 값을 리프노드에 도착하기 전에 찾을 때도 있음
- B-트리의 단점
	- 일부만 조기에 발견됨
	- 리프노드가 아닌 노드들이 커져 fan-out이 감소함(노드당 search key 값 수)
	- b+tree보다 깊고, 삽입과 삭제가 복잡함(Bucket Point)가 있기 때문
	- 구현이 어려움

## multiple - key access
- 특정 유형의 쿼리에 멀티플 인덱스를 사용함
- Bitmap 인덱스는 몇몇 케이스에 대해 빠른 속도로 쿼리에 대한 동작이 가능함
- 

## Indices on Multiple Keys
- composite searchkey 는 검색키가 하나 이상의 속성이 결합된것
- 인덱스를 composite search key에 만든다

## Other Features
- Covering indices
	- 일부 쿼리가 실제 레코드를 가져오지 않도록 인덱스에 속성 추가
		- 특히 secondary indices에 효과적임, 실제 레코드를 확인하지 않으니!
		- 시간절감
	- 추가 속성은 리프에만 저장 가능하다

## Bitmap Indices
- 비트맵 인덱스는 멀티 키에 대해 효과적인 쿼리가 가능한 특별한 유형의 인덱스임
- Relation r의 속성 A로 이루어진 비트맵 인덱스는 A가 가질 수 있는 각 값에 대해 하나의 비트맵으로 구성된다.
- 비교적 적은 수의 교유한 값을 갖는 속성에 적용 가능함( 성별, 나라 등)
- 단순히 비트들의 배열
- 가장 간단한 유형의 비트맵 인덱스 : 각 속성값에 대한 비트맵을 가지는 것
	- 비트맵은 레코드만큼의 비트를 가짐
	- Value v에 대해 비트맵에서 레코드가 해당 값 v를 가진 경우에는 bit를 1로 표시하고 아닌 경우에는 0으로 표시하낟.
- 비트맵 인덱스는 멀티플 속성 쿼리에 효과적
	- 하지만 단일 속성에는 효과적이지 않음
- 비트맵 연산을 하는 쿼리들에 유용함 intersection, union, complementation
- 각각의 연산은 같은 크기를 가진 두 개의 비트맵을 사용하고 해당 비트맵에 연산을 적용하여 결과 비트맵을 가져온다
	- 연산 이후 필요한 튜플 검색 가능
	- 일치하는 튜플을 세는 속도가 매우 빠름
- 삭제를 적절하게 처리해야한다.
	- 중간값이 삭제될 경우, 뒷 값들을 앞으로 한칸씩 옮겨야함 또는 0으로 채움
	- 존재 비트맵은 레코드 위치에 유효한 레코드가 있는지의 여부를 기록함
	- 0 - x, 1. - o
	- 보안성이 필요함 -> Not검사시 유효성 검사가 함께 적용되어야 함
- 비트맵은 널값을 포함한 모든 값에 대해 유지되어야함
	- Not 에 대한 SQL null의 의미를 올바르게 적용하려면 not - bitmap A Null의 결과를 교차
## 비트맵 연산의 효율적인 구현
- 비트맵은 B+트리의 리프수전에서 Tuple ID목록 대신에 사용할 수 있으며 일치하는 레코드 수가 많은 값에 사용할 수 있다.

## 비트맵 인덱스 - 마지막 포인트
- 비트맵 인덱스의 마지막 포인트
	- 비트맵 인덱스를 유용하게 만드는 것은 상대적으로 낮은 차수임
	- 단일 비트맵 인덱스를 테이블에 배치하는 것은 무의미?
		- NO, 비트맵 인덱스는 and 및 or을 수행하기 시작할 때만 결과를 생성하기 시작하기 땜누에 다른 비트맵 인덱스와 결합하여 유용성을 도출함
	- 읽는 환경에서는 B+트리보다 빠름
	- 비트맵 인덱스는 복합 컬럼 인덱스를 만들 필요가 없다
	- 결과적으로 비트맵 인덱스는 크고, 작은 차수, 읽는 호나경, 정적인 데이터 테이블에 적합하다.
## Index Definition in SQL