## Design and implementation
수행가능한 소프트웨어 시스템이 개발되는 단계

- 소프트웨어 설계 및 구현은 언제나 상호연계적이다.

직접 만들거나 구매
- 많은 도메인에서 구매하여 설계
- 직접 개발 -> 설계 과정을 어떻게 해당 시스템을 형상화하여 시스템 요구사항을 달성하는가가 초점이 됨

## An object-oriented design process
적용
- 구조화된 객체지향설계는 많은 시스템 모델을 개발하기 때문에 작은 시스템 개발에는 비용대비 효과적이지 않을 수 있음
- 큰 시스템 개발의 경우처럼 많은 그룹의 사람들에 의해 개발될 때 좋음

객체지향적 설계는 창의적인 과정이나 공통적인 활동을 포함함
1. 시스템에서 사용할 콘텍스트와 모드를 결정
2. 시스템 아키텍쳐 결정
3. 근본적인 시스템 오브젝트들 확인
4. 디벨롭
5. 오브젝트 인터페이스 명세

### [1]System context and interactions
Activities
- 개발하고자 하는 시스템과 외부 환경과의 관계를 이해하는 과정
- 시스템의 경계를 설정함
	- 어떤 특성이 설계된 시스템에서 구현되는지
	- 어떤 특성이 연관된 시스템에 있는지

생성되는 모델
- context model : 개발 대상 시스템/외부 시스템을 보임
- interaction model : 시스템이 환경과 어떻게 상호작용하는 가를 보임

### [2] Architectural design
- 주요 컴포넌트들과 그들간 상호관계를 밝혀냄
- 아키텍쳐별 패턴들을 이용하여 컴포넌트들를 조직화함(organize)

### [3] Object class identification
- 오브젝트 클래스를 식별하는 것은 매우 어려운 작업임
	- 편법이 없음
	- 오브젝트 식별은 _반복적인 과정_ 임

- 식별을 위한 접근법
	- 시스템의 자연어 설명을 기반으로한 공식적 접근법 사용
	- 어플리케이션 도메인에서 유형을 식별
	- 행동적 접근법
	- 시나리오 기반 분석 사용

### [4] 모델 설계
- 모델 설계
	- 오브젝트, 오브젝트 클래스 및 이들간의 관계를 보임
	- 동적 모델 : 클래스 및 관계를 통해 시스템의 정적인 구조를 보임
	- 동적 모델 : 객체간 동적 상호작용을 보임

- 디자인 모델 종류
	- 하위시스템 모델들 : 오브젝트를 일관된 하위 시스템으로 논리적으로 그룹화하
	- 시퀀스 모델 : 객체 상호 작용의 시퀀스
	- 상태 머신 모델 : 개별 객체가 이벤트에 반응하여 상태를 변경하는 방식
	- 기타 : 유스케이스 모델, 집계 모델, 일반화 모델 등

#### 서브시스템 모델
논리적으로 관련된 객체들의 그룹으로 보임

![](https://i.imgur.com/hGjpIiO.png)

#### 시퀀스 모델들
객체간 발생되는 상호작용, 즉 메시지 패싱에 대한 행위를 시간 축 중심으로 나타냄

구성요소
- 참여 객체 : 
	- 여러 개 존재할 수 있음
	- 참여 객체 간의 상호작용은 일반적으로 왼쪽에서 오른쪽으로 진행하도록 표현
	- 액터도 참여 객체의 한 유형으로 고려될 수 있음
- 시간 축
	- 다이어그램의 세로축
	- 메시지 전달의 순서를 위에서 아래 방향으로 나타내며, 업무의 처리흐름과 일치해야함
	- 시간 축은 각 객체가 활성화된 시간을 점선으로 표시, 객체의 라이프라인이라고 함
- 실행사건
	- 실행 동작이 발생한느 기간을 길쭉한 사각형의 실행 사건으로 표현
- 메시지 전달
	- 객체 간의 상호작용을 나타내는 기본 요소, 객체 간의 함수 호출을 의미
	- 호출되는 메소드의 이름과 매개변수가 화살표로 표시됨
- 제어 로직
	- 소프트웨어의 행위를 표현함. 선택, 반복, 병렬처리 등
	- 결합형 심볼. 반복적, 기본적인 요소인 조각들을 묶어 추상화된 개념의 제어 로직을 표현
	- 다이어그램의 복잡도를 감소시키며, 이해도를 높이는 역할

#### 상태 다이어그램
- 객체가 다양한 서비스 요청사항에 대해 어떻게 반응하는가 또한 요청에 따를 상태의 변화를 묘사함

### [5] 인터페이스 명세
- 오브젝트 인터페이스를 명세하여 오브젝트 및 컴포넌트에 대한 설계가 동시에 일어날 수 있도록 하는 것이 필요

# Design Patterns
## [1] Facade Patterns
라이브러리 / 프레임워크/ 클래스들의 복잡한 집합에 대한 단순화된 인터페이스를 제공하는 구조적 디자인 패턴
![](https://i.imgur.com/rHcjtTV.png)

- Facade를 이용하여 start, stop엔진에 대한 모든 복잡한 내용을 은닉시킴

## [2] The Observer Pattern
- Description : 객체의 상태를 보여주는것과 분리하여 다양한 디스플레이 제공지원, 객체 상태의 변화가 자동적으로 알려짐 -> 디스플레이 내용이 변함
- 문제 설명 - 상태 정보에 대해 다양한 방법으로 display하고자 할 때
	- 적용되는 경우 : 한개이상의 방법으로 상태정보가 display될 때, 상태정보를 유지하고 있는 객체는 어떤 방식으로 이정보가 display되는지 알 필요없게 할 때
- 해결 설명 - 두가지 추상 객체 : subject, observer
		   -  두가지 콘크리트 객체 : 콘크리트 서브젝트, 콘크리트 오브젝트
		   - 추상객체는 모든 경우에 적용될 수 있는 일반적인 operation만을 포함
		   - 콘크리트서브젝트는 서브젝트 클래스를 상속받아 정의, 화면에 보일 내용만 유지
		   - 옵저버는 상태가 변화되었음을 알려주는 담당 -> 서브젝트는 옵저버를 추가하거나 제거 가능
		   - 콘크리트옵저버는 추상객체인 옵저버의 업데이트 메소드를 구현하여 콘크리트서브젝트의 상태를 복사하여 유지
		   - 콘크리트옵저버는 상태가 변화될 때마다 자동적으로 상태 변화를 화면에 보여줌
- 결과 : 서브젝트는 추삭 옵저버에 대해서만 알고 있으며 콘크리트 클래스에 대해 아는바 없음 -> 해당 객체간의 커풀링이 최소화될 수 있음

## 다양한 패턴들
옵저버 패턴 : 여러 객체에 다른 객체의 상태가 변경되었음을 알림
Facade 패턴 : 점진적으로 개발되는 여러 관련 객체에 대한 인터페이스 정리
iterator pattern : 구현방법에 관계없이 컬렉션 요소에 엑세스하는 표준 방법제공
decorator 패턴 : 런타임에 기존 클래스의 기능을 확장할 수 있는 가능성 허용

# Implementation Issues
## Implementation Issues 
- 재사용 : 재사용률의 최대화를 어떻게 이끌어낼 것인가?
- confihuration management : 컴포넌트들의 다양한 버전을 유지해야함 -> 관리어케?
- host- target development : 개발환경과 실행환경을 연결시키는 방법

### [1] Reuse : Levels
- 추상적 레벨 : 소프트웨어를 재사용하는 것이 아닌, 설계시 도출된 지식을 재활용함
- 객체 레벨 : 라이브러리에 있는 오브젝트를 재사용
- 컴포넌트 레벨
- 시스템 레벨 : 전체 어플리케이션 시스템을 재사용
- 
